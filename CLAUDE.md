# Strawman

Minimal Lisp interpreter in Racket. All code is generated by Claude Code —
no human-written code. Structured around *Lisp in Small Pieces* (Queinnec).

## Commands

```bash
racket strawman.rkt              # Start the REPL
racket strawman.rkt file.straw   # Run a script
raco test tests/                 # Run full test suite
raco test tests/test-lexer.rkt   # Run a single test file
./ralph.sh                       # Autonomous TDD loop
./ralph.sh --dry-run             # Preview without invoking Claude
```

## Architecture

```
Source string → Lexer → Tokens → Parser → AST → Evaluator → Value
                                                    ↑
                                              Environment
                                              (lexical scope)
```

| File | Role |
|------|------|
| `strawman.rkt` | Entry point: REPL or file execution |
| `src/lexer.rkt` | `tokenize : string -> (listof token)` |
| `src/parser.rkt` | `parse : (listof token) -> s-expr` |
| `src/env.rkt` | Environment: `make-env`, `env-lookup`, `env-set!`, `env-update!`, `env-extend` |
| `src/eval.rkt` | `straw-eval : s-expr × env -> value` |
| `src/builtins.rkt` | `default-env` with arithmetic, comparison, list ops, I/O |
| `src/repl.rkt` | `run-repl` — read/eval/print loop with error recovery |

Each source file uses `#lang racket` and `provide`s its public API.
Each has a matching test file in `tests/` using `rackunit`.

## Specification & Plan

| File | What it contains |
|------|-----------------|
| `spec.md` | 10 epics, 37 user stories, each with narrative, requirements, test matrix, acceptance criteria, definition of done |
| `plan.md` | 15 phases with per-task `- [ ]` checkboxes tracking TDD progress |
| `ralph.sh` | Autonomous driver that reads plan.md and invokes Claude Code |

**Epics map to *Lisp in Small Pieces* chapters:**

1. Basic Interpreter (lexer, parser, eval, closures, builtins, REPL)
2. Namespaces & Recursion (`let`, `let*`, `letrec`, define shorthand)
3. Escape & Continuations (CPS evaluator, `call/cc`, `catch`/`throw`)
4. Assignment & Side Effects (box model, `set-car!`/`set-cdr!`, vectors)
5. Denotational Semantics (formal semantics document, semantics-driven tests)
6. Fast Interpretation (pretreatment, lexical addressing, benchmarks)
7. Bytecode Compilation (instruction set, compiler, VM)
8. Eval & Reflection (`eval`, first-class environments)
9. Macros (`define-macro`, quasiquote, `cond`/`when`/`unless`)
10. Object System (classes, generics, inheritance)

Epics 1–2 are the MVP. Later epics build on top.

## TDD Discipline

Every task follows this exact cycle:

```
1. RED      Write a failing test for one Test Matrix row from spec.md
2. RED      Run `raco test tests/` — confirm it fails for the right reason
3. GREEN    Write the minimum production code to pass
4. GREEN    Run `raco test tests/` — confirm ALL tests pass (not just the new one)
5. FIX      If anything fails, fix code until green
6. REFACTOR Clean up while keeping all tests green
7. REPEAT   Next Test Matrix row
```

**Hard rules:**
- Never write production code without a failing test first
- Never skip step 2 — seeing the failure confirms the test tests what you think
- One Test Matrix row per RED→GREEN cycle (keep cycles small)
- Run the full suite after every GREEN
- Commit after completing each story (all its Test Matrix rows green)
- Do not modify `plan.md` checkboxes — `ralph.sh` handles that
- Do not add features beyond what the current task requires

## Coding Conventions

**Racket style:**
- `#lang racket` for every file
- Prefer `match` and `cond` over nested `if`
- Use `provide`/`require` for module boundaries
- Prefer pure functions; mutation only where necessary (environments)
- Structs for closures and tokens, not ad-hoc lists

**Testing:**
- Every module in `src/` gets a corresponding `tests/test-<module>.rkt`
- Use `rackunit`: `check-equal?`, `check-exn`, `test-case`
- Test names should describe the behavior, not the implementation
- Error tests use `check-exn` with a regexp matching the expected message

**Naming:**
- The language is called Strawman Lisp
- Source files use the `.straw` extension
- The evaluator function is `straw-eval` (not `eval`, to avoid shadowing Racket's)

## Ralph Loop (`ralph.sh`)

The autonomous driver that builds the interpreter without human coding:

1. Reads `plan.md`, finds the first unchecked `- [ ]` item
2. Extracts phase header (`## Phase N — ...`) and story header (`**E1.4 — ...`)
3. Builds a prompt telling Claude Code to execute one TDD cycle for that task
4. Invokes `claude -p` with `--dangerously-skip-permissions --max-turns 50`
5. **Independently** runs `raco test tests/` to verify — Claude's claim is not trusted
6. If tests pass: marks `- [x]` in plan.md
7. If tests fail: leaves unchecked, retries (up to 3 times, then stops for human)
8. When all checkboxes in a story are `[x]`: auto-commits
9. Logs everything to `ralph.log`

## Value Representation

| Strawman type | Racket representation |
|--------------|----------------------|
| Number | Racket number (`integer?`, `flonum?`) |
| String | Racket string |
| Boolean | `#t` / `#f` |
| Symbol | Racket symbol |
| Pair / List | Racket cons cells (`cons`, `car`, `cdr`) |
| Empty list | `'()` |
| Closure | Struct: `(closure params body env)` |
| Builtin | Struct wrapping a Racket procedure |
| Void | Racket `(void)` — not printed in REPL |

## Special Forms vs Builtins

**Special forms** (handled in the evaluator — custom evaluation rules):
`quote`, `if`, `begin`, `define`, `set!`, `lambda`, `and`, `or`,
`let`, `let*`, `letrec`

**Builtins** (Racket procedures in the default environment — normal eval):
`+`, `-`, `*`, `/`, `mod`, `<`, `>`, `<=`, `>=`, `=`, `equal?`,
`cons`, `car`, `cdr`, `list`, `null?`, `pair?`, `not`,
`number?`, `string?`, `symbol?`, `boolean?`, `procedure?`,
`display`, `newline`

## Error Handling

- Unbound variable: `"unbound variable: <name>"`
- Cannot set! unbound: `"cannot set! unbound variable: <name>"`
- Not a procedure: `"not a procedure: <value>"`
- Arity mismatch: `"arity mismatch: expected <n>, got <m>"`
- Division by zero: `"division by zero"`
- Car/cdr on non-pair: `"car: expected pair"` / `"cdr: expected pair"`
- Type errors: `"expected number"`, `"expected pair"`, etc.
- The REPL catches all errors, prints `Error: <message>`, and continues
