# Strawman — Minimal Lisp Interpreter in Racket

## Project Overview
A minimal Lisp interpreter built incrementally in Racket using strict TDD,
structured around *Lisp in Small Pieces* by Christian Queinnec. All code is
generated by Claude Code — no human-written code.

## Build & Run
- **Run REPL**: `racket strawman.rkt`
- **Run tests**: `raco test tests/`
- **Run single test**: `raco test tests/test-lexer.rkt`
- **Run a script**: `racket strawman.rkt <file.straw>`
- **Run Ralph loop**: `./ralph.sh` (autonomous TDD driver)
- **Dry run Ralph**: `./ralph.sh --dry-run` (preview without invoking Claude)

## Architecture
Source → Tokens → AST → Eval → Result

- `src/lexer.rkt` — Tokenizer
- `src/parser.rkt` — Parser
- `src/env.rkt` — Environments (lexical scope)
- `src/eval.rkt` — Evaluator
- `src/builtins.rkt` — Built-in primitives
- `src/repl.rkt` — REPL
- `strawman.rkt` — Entry point

## Key Files
- `spec.md` — Full specification: 10 epics, 37 user stories with test matrices
- `plan.md` — TDD implementation plan with per-task checkboxes
- `ralph.sh` — Autonomous loop that drives Claude Code through the plan

## TDD Cycle
Every task follows this loop — no exceptions:

```
1. RED    — Write a failing test (one row from the spec's Test Matrix)
2. RED    — Run `raco test tests/` — confirm it fails for the right reason
3. GREEN  — Write the minimum code to make the test pass
4. GREEN  — Run `raco test tests/` — confirm ALL tests pass
5. FIX    — If any test fails, fix code until all tests pass
6. REFACTOR — Clean up while keeping tests green
```

**Rules:**
- Never write production code without a failing test first
- Each cycle covers one Test Matrix row from spec.md
- Run the full suite after every GREEN, not just the new test
- Commit after completing each story (all its Test Matrix rows green)

## Coding Conventions
- `#lang racket` for all source files
- Prefer `match`, `cond`, pattern matching over nested `if`
- Test with `rackunit`; every module gets a test file in `tests/`
- Use `provide`/`require` for module interfaces
- Prefer pure functions; mutation only where necessary (environments)

## Ralph Loop (`ralph.sh`)
The autonomous driver script:
1. Reads `plan.md`, finds the first unchecked `- [ ]` item
2. Extracts phase and story context for the prompt
3. Invokes `claude -p` with TDD instructions
4. Independently verifies with `raco test tests/`
5. Marks `- [x]` only if tests pass; retries up to 3 times on failure
6. Auto-commits when all checkboxes in a story are complete
7. Logs everything to `ralph.log`
